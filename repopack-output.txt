================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-09T06:05:54.849Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
static/
  js/
    script.js
  styles.css
templates/
  index.html
.gitignore
app.py
KUITANSI_FINAL.docx
Procfile
README.md
requirements.txt

================================================================
Repository Files
================================================================

================
File: static/js/script.js
================
let components = [];

function updateComponentsList() {
    const list = document.getElementById('components-list');
    list.innerHTML = '';
    components.forEach((component, index) => {
        const div = document.createElement('div');
        div.className = 'component-item';
        let html = `
            <span>${component.name} (${component.type})</span>
            <input type="file" accept="${getAcceptAttribute(component.type)}" onchange="handleFileUpload(event, ${index})">
            <span class="file-name">${component.file ? component.file.name : 'No file selected'}</span>
        `;
        
        if (component.type === 'Foto') {
            html += `
                <input type="text" placeholder="Image Caption" value="${component.caption || ''}" onchange="handleCaptionChange(event, ${index})">
            `;
        }
        
        html += `
            <button onclick="removeComponent(${index})">Hapus</button>
            <div class="move-buttons">
                <button onclick="moveComponent(${index}, -1)">↑</button>
                <button onclick="moveComponent(${index}, 1)">↓</button>
            </div>
        `;
        
        div.innerHTML = html;
        list.appendChild(div);

        if (component.file) {
            const fileInput = div.querySelector('input[type="file"]');
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(component.file);
            fileInput.files = dataTransfer.files;
        }
    });
}

function handleCaptionChange(event, index) {
    components[index].caption = event.target.value;
}

function getAcceptAttribute(type) {
    switch (type) {
        case 'Foto':
            return '.png,.jpg,.jpeg,.gif';
        case 'Dokumen':
            return '.doc,.docx';
        case 'PDF':
            return '.pdf';
        default:
            return '.png,.jpg,.jpeg,.gif,.doc,.docx,.pdf';
    }
}

function addComponent() {
    const name = document.getElementById('new-component-name').value;
    const type = document.getElementById('new-component-type').value;
    
    if (name) {
        components.push({ name, type, file: null });
        updateComponentsList();
        document.getElementById('new-component-name').value = '';
    } else {
        alert('Component name cannot be empty!');
    }
}

function removeComponent(index) {
    components.splice(index, 1);
    updateComponentsList();
}

function moveComponent(index, direction) {
    const newIndex = index + direction;
    if (newIndex >= 0 && newIndex < components.length) {
        [components[index], components[newIndex]] = [components[newIndex], components[index]];
        updateComponentsList();
    }
}

function handleFileUpload(event, index) {
    const file = event.target.files[0];
    if (file) {
        components[index].file = file;
        updateComponentsList();
    }
}

function generateSPJ() {
    const templateName = document.getElementById('template-name').value;
    const tanggalAcara = document.getElementById('date').value;

    if (!templateName) {
        alert('Please enter template name!');
        return;
    }
    if (!tanggalAcara) {
        alert('Please enter event date!');
        return;
    }
    if (components.length === 0) {
        alert('Please add at least one component!');
        return;
    }

    const formData = new FormData();
    formData.append('templateName', templateName);
    formData.append('tanggalAcara', tanggalAcara);

    components.forEach((component, index) => {
        if (component.file) {
            formData.append('files', component.file);
            formData.append(`file_types`, component.type);
            if (component.caption) {
                formData.append(`captions`, component.caption);
            }
        }
    });

    fetch('/generate', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = `/download/${data.file}`;
        } else {
            alert(`Error: ${data.error}`);
        }
    })
    .catch(error => console.error('Error:', error));
}

document.getElementById('add-component-btn').addEventListener('click', addComponent);
document.getElementById('generate-spj-btn').addEventListener('click', generateSPJ);

updateComponentsList();

================
File: static/styles.css
================
body {
    font-family: Verdana, sans-serif;
    max-width: 600px;
    margin: 0 auto;
    padding: 20px;
}

h1, h2 {
    text-align: center;
}

#template-form, #add-component-form {
    margin-bottom: 20px;
}

input, select, button {
    font-family: Verdana, sans-serif;
    margin: 5px 0;
    padding: 5px;
}

button {
    background-color: black;
    color: white;
    border: none;
    cursor: pointer;
}

button:hover {
    opacity: 0.8;
}

.component-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.component-item button {
    margin-left: 10px;
}

.move-buttons {
    display: flex;
    flex-direction: column;
}

.move-buttons button {
    padding: 2px 5px;
    font-size: 12px;
}

================
File: templates/index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPJ Generator</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <h1>SPJ Generator</h1>
    <h2>Asisten Otomatis untuk Membuat SPJ</h2>
    
    <div id="template-form">
        <label for="template-name">Nama template:</label>
        <input type="text" id="template-name" required>
    </div>

    <div id="date-form">
        <label for="date">Tanggal Acara:</label>
        <input type="date" id="date" required>
    </div>

    <h3>Daftar Komponen</h3>
    <div id="components-list"></div>

    <div id="add-component-form">
        <input type="text" id="new-component-name" placeholder="Nama Komponen">
        <select id="new-component-type">
            <option value="Foto">Foto</option>
            <option value="Dokumen">Dokumen</option>
            <option value="PDF">PDF</option>
        </select>
        <button id="add-component-btn">Tambah komponen</button>
    </div>

    <button id="generate-spj-btn">Generate SPJ</button>

    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>

================
File: .gitignore
================
venv/
spj_generator_key.pem
__pycache__
*.pyc
uploads/
.env

================
File: app.py
================
import os
from flask import Flask, render_template, request, jsonify, send_file
from werkzeug.utils import secure_filename
from docx import Document
from docx.shared import Inches
from docxcompose.composer import Composer
from pdf2docx import Converter
import io
import boto3
from botocore.exceptions import ClientError
from PIL import Image
import tempfile
import logging
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH

app = Flask(__name__)

AWS_ACCESS_KEY_ID = os.environ.get('AWS_ACCESS_KEY_ID')
AWS_SECRET_ACCESS_KEY = os.environ.get('AWS_SECRET_ACCESS_KEY')
S3_BUCKET_NAME = os.environ.get('S3_BUCKET_NAME')

if not all([AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, S3_BUCKET_NAME]):
    print("Warning: One or more required environment variables are missing.")

# S3 configuration
s3_client = boto3.client(
    's3',
    aws_access_key_id=AWS_ACCESS_KEY_ID,
    aws_secret_access_key=AWS_SECRET_ACCESS_KEY
)
s3_bucket_name=S3_BUCKET_NAME

ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'doc', 'docx', 'pdf'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def is_image(file_content):
    try:
        Image.open(io.BytesIO(file_content))
        return True
    except IOError:
        return False

def is_pdf(filename):
    return filename.lower().endswith('.pdf')

def convert_pdf_to_docx(pdf_content):
    try:
        with tempfile.NamedTemporaryFile(suffix='.pdf', delete=False) as pdf_temp:
            pdf_temp.write(pdf_content)
            pdf_temp_path = pdf_temp.name

        docx_temp = tempfile.NamedTemporaryFile(suffix='.docx', delete=False)
        docx_temp_path = docx_temp.name
        docx_temp.close()

        # Convert PDF to DOCX
        cv = Converter(pdf_temp_path)
        cv.convert(docx_temp_path)
        cv.close()

        # Read the converted DOCX
        with open(docx_temp_path, 'rb') as docx_file:
            docx_content = docx_file.read()

        # Clean up temporary files
        os.unlink(pdf_temp_path)
        os.unlink(docx_temp_path)

        return docx_content
    except Exception as e:
        logger.error(f"Error converting PDF to DOCX: {str(e)}")
        return None

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def process_files(files, template_name, date):
    merged_doc = Document()
    composer = Composer(merged_doc)
    
    file_types = request.form.getlist('file_types')
    captions = request.form.getlist('captions')
    
    for file, file_type, caption in zip(files, file_types, captions + [None] * len(files)):
        try:
            logger.debug(f"Processing file: {file.filename}")
            file_content = file.read()
            if file_type == 'Foto':
                logger.debug(f"{file.filename} is an image")
                if caption:
                    para = merged_doc.add_paragraph()
                    para.alignment = WD_ALIGN_PARAGRAPH.CENTER
                    run = para.add_run(caption)
                    run.bold = True
                    run.font.size = Pt(12)
                pil_image = Image.open(io.BytesIO(file_content))
                img_stream = io.BytesIO()
                pil_image.save(img_stream, format=pil_image.format)
                img_stream.seek(0)
                merged_doc.add_picture(img_stream, width=Inches(6))  # Increased width for better visibility
            elif file_type == 'PDF':
                logger.debug(f"{file.filename} is a PDF")
                docx_content = convert_pdf_to_docx(file_content)
                if docx_content is None:
                    logger.error(f"PDF conversion failed for {file.filename}")
                    continue
                doc = Document(io.BytesIO(docx_content))
                composer.append(doc)
            else:
                logger.debug(f"{file.filename} is a document")
                doc = Document(io.BytesIO(file_content))
                composer.append(doc)
        except Exception as e:
            logger.error(f"Error processing {file.filename}: {str(e)}")
            continue
    
    output_filename = f'SPJ_{template_name}_{date}.docx'
    output_stream = io.BytesIO()
    composer.save(output_stream)
    output_stream.seek(0)
    
    # Upload to S3
    try:
        s3_client.upload_fileobj(output_stream, S3_BUCKET_NAME, output_filename)
    except Exception as e:
        logger.error(f"Error uploading to S3: {str(e)}")
        raise
    
    return output_filename

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/generate', methods=['POST'])
def generate_spj():
    template_name = request.form.get('templateName')
    date = request.form.get('tanggalAcara')
    files = request.files.getlist('files')
    
    if not template_name or not date or not files:
        return jsonify({'error': 'Missing required data'}), 400
    
    valid_files = [f for f in files if f and allowed_file(f.filename)]
    
    if not valid_files:
        return jsonify({'error': 'No valid files to process'}), 400
    
    try:
        merged_filename = process_files(valid_files, template_name, date)
        return jsonify({'success': True, 'file': merged_filename})
    except Exception as e:
        print(f"Error processing files: {str(e)}")  # line for debugging
        return jsonify({'error': str(e)}), 500

@app.route('/download/<filename>')
def download_file(filename):
    try:
        file_obj = s3_client.get_object(Bucket=S3_BUCKET_NAME, Key=filename)
        return send_file(
            io.BytesIO(file_obj['Body'].read()),
            as_attachment=True,
            download_name=filename,
            mimetype='application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        )
    except ClientError as e:
        return str(e), 404

if __name__ == '__main__':
    app.run(debug=False)

================
File: Procfile
================
web: gunicorn app:app

================
File: README.md
================
# spj-generator

================
File: requirements.txt
================
Babel==2.15.0
blinker==1.8.2
boto3==1.34.156
botocore==1.34.156
click==8.1.7
docxcompose==1.4.0
fire==0.6.0
Flask==3.0.3
fonttools==4.53.1
gunicorn==22.0.0
itsdangerous==2.2.0
Jinja2==3.1.4
jmespath==1.0.1
lxml==5.2.2
MarkupSafe==2.1.5
numpy==2.0.1
opencv-python-headless==4.10.0.84
packaging==24.1
pdf2docx==0.5.8
pillow==10.4.0
PyMuPDF==1.24.9
PyMuPDFb==1.24.9
python-dateutil==2.9.0.post0
python-docx==1.1.2
python-dotenv==1.0.1
s3transfer==0.10.2
setuptools==72.1.0
six==1.16.0
termcolor==2.4.0
typing_extensions==4.12.2
urllib3==2.2.2
Werkzeug==3.0.3
